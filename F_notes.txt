// Обозначим за pi(n) -- количество простых от 1 до n,
//   phi(n, b) -- количество чисел от 1 до n, у которых
//   в разложении на простые все простые больше b-го
//   простое (индексация с единицы), единица тоже
//   считается (там простых в разложении нет, потому условие верно).
// Выберем y в [cbrt(n); sqrt(n)] (окажется, оптимально взять
//   y = cbrt(n) (log(n)) ^ (2/3), подробнее тут:
//   https://codeforces.com/blog/entry/91632).
// pi(n) = phi(n, pi(y)) + pi(y) - F - 1.
//   Почему? phi(n, pi(y)) считает количество простых от
//   pi(y)-го простого до n и составные, у которых каждое
//   простое в разложении > pi(y)-го простого.
//   Кроме этого от 1 до n есть составные, у которых все
//   простые больше pi(y)-го простого.
//   Как элегантно исключить эти числа? y в [cbrt(n); sqrt(n)],
//   потому у любого такого составного числа сумма степеней
//   простых в разложении не более двух, иначе как минимум три,
//   но любое простое больше primes[pi(y) - 1] ~=
//   pi(y) ln(pi(y)) >= y / ln(y) ln(pi(y)) ~= y / ln(y)
//   (ln(y) - ln(ln(y)) >= cbrt(n) (теорема о распределении
//   простых чисел: примерное значение n-го простого,
//   эквивалентная величина для pi(k) (эквивалентные величины
//   оцениваюся через друг друга с некоторой константой, потому
//   всё ок, надо наш алгоритм использовать для больших n, а для
//   маленьких использовать наивный), тогда само число
//   k > y^3 >= cbrt(n)^3 = n, противоречие, т.к. рассмотрели
//   число от 1 до n. Значит, оба сомножителя не более sqrt(n),
//   они у нас будут, т.к. мы простые считаем от 1 до n / y >=
//   sqrt(n). Тогда посчитаем простые числа от 1 до n / y обычным
//   просеиванием за O(n / y), двумя указателями посчитаем F за
//   O(n / y). Все нужные числа имеют два простых сомножителя,
//   потому их не пропустим, с другой стороны все числа, которые
//   вычислили входят в нужные. Ровно их и посчитаем, получается.
//   Вычтем единицу, т.к. считали единицу в phi. Простые
//   не больше y мы тоже посчитали, pi(y).
// Как считать phi(n, pi(y))? pi(y) посчитать можем, обычным
//   просеиванием. Осталось только посчитать phi.
//   Функцию phi(m, b) при m <= max { y, n / y } (= n / y, т.к.
//   n / y > sqrt(n), y <= sqrt(n)) мы можем посчитать с помощью
//   обычного просеивания. У нас получится массив наименьших простых
//   делителей для каждого числа, нужно посчитать числа i <= m, у
//   которых lowest_prime_div[i] > primes[b - 1] (b -- номер
//   простого в 1-индексации).
// Однако, m у нас большое изначально. Для phi(m, b) есть
//   рекуррентное соотношение:
//   phi(m, b) = phi(m, b - 1) - phi(m / primes[b - 1], b - 1).
//   Числа не более m, у которых все простые больше b-го,
//   вложены в числа, у которых все простые больше (b-1)-го.
//   Что в разности? Те числа, у которых не все простые больше
//   b-го, но все простые больше (b-1)-го. Это те числа,
//   у которых есть b-ое простое в разложении. Среди чисел от
//   1 до m, тем, у которых есть b-ое простое, соответствуют
//   однозначно числа 1 до m / primes[b - 1] (делим на это
//   простое, получаем соответствующее). Поскольку это целые
//   числа, это же множестко -- это целые от 1 до
//   floor(m / primes[b - 1]).
// Сколько будет рекурсивных вызовов до достижения подходящей границы?
//   floor(floor(m / p[1]) / p[2]) = floor(m / (p[1] p[2])),
//   т.к. для любых чисел a, b, c floor(floor(a / b) / c) = floor(a / (bc)).
//   Доказательство.
//   k_3 = floor(a / (bc)) <=> k_3 bc <= a < (k_3 + 1) bc
//   k_1 = floor(a / b) <=> k_1 b <= a < (k_1 + 1) b.
//   k_2 = floor(floor(a / b) / c) <=> k_2 c <= floor(a / b) = k_1 < (k_2 + 1) c
//     <=> k_2 c <= floor(a / b) = k_1 <= (k_2 + 1) c - 1
//     => k_2 bc <= a < ((k_2 + 1) c - 1) + 1) b
//     <=> k_2 bc <= a < k_2 bc.
//     => k_2 = k_3.
//  Т.е. первый аргумент для phi при рекурсивном вычислении выглядит так:
//    n, floor(n / p[y - 1]), floor(n / p[y - 2]), ...
//    Мы останавливаемся при floor(n / floor(y)). Тогда всего значений floor(n / t)
//    для 1 <= t < y не более y. А второй аргумент меняется от pi(y) до 1.
//    При вычислении phi(y, pi(y)) всего пар значений y * pi(y).
// Надо сохранить не только пару значений, но ещё знак, который они вкладывают в
//   значение phi(n, pi(y)).
// Каждое слагаемое после раскрытия уже вычислимо через таблицу от обычного
//   просеивания. Изобразим на плоскости пары точек (lowest_prime_div[t], t).
//   phi(m, b) -- это количество точек в прямоугольнике
//   prime[b - 1] + 1 <= lowest_prime_div <= n / y,
//   1            <= t                <= m.
// Посчитать ответы на эти запросы можем деревом Фенвика, например, с помощью
//   сканирующей прямой, поддерживая префиксную сумму для каждой ординаты.
//   В начале отсортируем запросы по t, затем при начале обработки, не включая
//   точки текущей абсциссы в количество, посчитаем сумму слева от левой границы
//   прямоугольника, а в конце посчитаем для запросов, которые заканчиваются,
//   сумму справа от правой границы прямогольника (она уже будет включать точки
//   внутри).
// Этот этап работает за O((n / y) log(n / y) + q), просеивание работает за O(n / y),
//   pi(y) считаем за O(log(n / y)), F считаем за O(n / y) двумя
//   указателями (когда начинаем, первый указатель на простые на первом простом,
//   второй в конце, смещаем второй, пока не будет в произведении не меньше y + 1,
//   добавляем разность второго указателя и конца + 1). Второй указатель не левее
//   первого, т.к. иначе каждое число посчитаем дважды (кроме тех случаев, когда
//   это квадрат простого).
// pi(y) ~= y / ln(y) (распределение простых), потому q ~= y * y / ln (y).
// В общем, получается O(n^(2 / 3) (log(n))^(1 / 3)).
