// Алгоритм Манбера-Майерса. Строим суффиксный массив за
//   O(n log(n)) сортировкой зацикленных циклических сдвигов.
// Допишем нулевой символ в конец, который меньше всех остальных.
// Теперь суффикс из нулевого символа находится в начале массива.
// Лексикографический порядок суффиксов не изменится (к ним
//   просто дописался ноль):
//   если не один из двух суффиксов не был префиксом другого,
//   то в какой-то момент они начинают отличаться, до нуля
//   сравнение не доходит;
//   если был, то суффикс меньшей длины префикс суффикса большей,
//   раньше сравнение завершалось из-за разной длины строк, но
//   теперь у строки меньшей длины появляется нулевой символ
//   раньше.
// Другое доказательство: a < b, почему a' < b'? (штрих, если
//   допишем ноль). Если a < b при лексикографическом сравнении
//   потому, что встречается неравный символ, то до нуля
//   сравнение a' < b' не дойдет, сравнение не поменялось. 
//   Если a < b из-за того, что длина a < длины b, то теперь
//   будет сравниваться ноль с символом b, a' окажется меньше
//   b' так же, хотя и по другой причине.
// Теперь в конце суффиксов есть нулевой байт. Можем после этого
//   байта дописать любые строки, порядок суффиксов не изменится:
//   все суффиксы разной длины, потому в разных суффиксах
//   находится 0 в разных позициях. До дописанной строки
//   сравнение никогда не дойдет, поскольку на первом нуле
//   выяснится порядок, кто меньше. У кого встретился ноль, тот и
//   меньше. Если сравнить суффикс с самим собой, он тоже всё ещё
//   равен, у него хвост тот же.
// Тогда допишем к суффиксам ноль, а потом недостающие символы
//   из начала, а затем зациклим эту строку, сделав бесконечной.
//   Достаточно отсортировать эти бесконечные строки по первым n
//   символам, где n -- длина строки, и всё будет готово. Давайте
//   отсортируем по первой степени двойки, которая больше или
//   равна n. Сортировать будем сортировками подсчётом за O(n),
//   количество сравниваемых строк -- n + 1, это O(n), будет
//   log_2(n) итераций. Потому O(n log(n)).
// Можно дописывать не нулевой символ, а строго меньший всех
//   остальных в строке. Все доказательства будут работать.
// Для нашей задачи можем дописать заведомо меньший символ
//   0x10.
// Пусть S_i -- номер отрезка совпадающих элементов i-го суффикса 
//   после сортировки с k-ой итерации.
//   Как понять, что это такое? В результате любой сортировки
//   у нас сначала идут числа с наименьшим значением, затем
//   со вторым наибольшим и так далее. И числа с наименьшим,
//   если их было несколько, образуют отрезок. Аналогично числа
//   со вторым наименьшим значением и так далее.
//   Это же происходит и при лексикографической сортировке строк:
//     сначала сколько строк одинаковых, наименьших лексикографически,
//     затем строки вторые лексикогарфически и так далее. Внутри
//     отрезка находятся одинаковые строки, т.е. это просто одинаковые
//     строки из набора. Пронумеруем эти отрезки с нуля, по индексу из
//     исходного массива будем получать номер такого отрезка, где
//     элемент оказался.
//   В нашем случае мы сортируем по первым 2^k символам, потому по первым
//     k символам строки совпадают. И сами строки не храним, а храним их
//     начала в исходной строке.
//   Это ещё называют лексикографическим именем (алгоритм
//   Каркайнена-Сандерса, построение суфмассива за O(n)), компонентой
//   эквивалентности в разборах нашего алгоритма, что имеет смысл, т.к.
//    внутри отрезка все элементы равны.
// Пусть M_j -- отсортированный массив с началами суффиксов с итерации k.
// На итерации k + 1 надо отсортировать пары (S_i, S_{i + 2^k}).
//   Отсортировать по второй половине легко: возьмём M'_j = M_{j + 2^k},
//   зациклив индекс. Почему это то же самое, что отсортировать по второй
//   половине? TODO: посмотреть разбор этого алгоса, дописать. Сейчас я
//   TODO: просто знаю, что надо делать.
// Чтобы выучить алгоритм, рекомендую записать эти шаги, держать их в
//   голове.

// Этапы:
//  1) дополнение строки,
//  1.1) почему дополняем, порядок суффиксов не меняется?
//  1.2) почему ...
//  1.2) почему ...
//  1.2) почему ...
//  1.3) почему можно сортировать по первым ceil(log_2(n)) символам и всё ок?
//  2) сортировка по первому символа (2^k, k = 0),
//  3) сортировка 2^(k + 1), если отсортировано по 2^k:
//   3.1) сортировка по второй половине пары, почему действительно отсортровали.

// Для 1.3 что-то такое можно использовать.
// Сортируем зацикленные циклические сдвиги по первым 2^len_log символам.
// После сортировать нет смысла, т.к. результаты сравнений не поменяются,
//   потому что у всех зацикленных циклических суффиксов есть решетка,
//   у различных по длине она в разных местах, потому знак
//   неравенства становится гарантированно известен после просмотра
//   первых text.size() символов: обязательно встретим решетку, она
//   не совпадёт. Мб и раньше будет несовпадение.

// Этап 2.
// Сортируем по первому символу, это первые 2^k
//   символов для k = 0.
// Для сортировок подсчётом на следующих итерациях
//   надо знать алфавит, чтобы выделить массив.
//   Наш алфавит -- номера компонент эквивалентности.
//   На (k+1)-ой итерации мы сортируем по номерам с
//   предыдущей итерации: TODO: ПРОВЕРИТЬ, КОГДА НАПИШУ КОД.
//   Потому можно выделить массив на длину строки элементов,
//   т.к. номер компоненты начинается с нуля и их не больше,
//   чем суффиксов +1, это длина text_mod. Единственное, в
//   чем беда: при сортировке подсчётом по первому символу
//   номер компоненты равен номеру символа в алфавите.
//   Пересчитаем номер компоненты заново после сортировки, что там.

// Замечание 1.
// Исключающие префиксные суммы, как говорят публикации
//   алгоритма Каркайнена-Сандерса.
// Вообще, можно делать стабильную сортировку подсчётом
//  двумя способами: считать исключающие суммы,
//  количество элементов до компоненты, тогда перебирать
//  в прямом порядке отсоритрованный массив, в каждую
//  компоненту попадает наименьший. Или хранить включая,
//  тогда перебирать в обратном, в каждую компоненту
//  попадает наибольший, в конец компоненты.

// Замечание 2.
// Пока это ещё символы, можно смотреть в текст.
//   Дальше придется смотреть номера компонент
//   эквивалентности. И тогда понадобится новый
//   массив, чтобы не перезаписывать старые
//   значения.
// TODO: make this implementation detail, don't think about it.
// TODO: make a small version of this algo, on associative containers,
//   in python, so that it's small and concise, ready to be memorised.

// Переход к следующей итерации.
// Для перехода к следующей итерации нам нужна дополнительная память:
//   новый порядок, потому что мы сортируем по второй половине
//   сдвигом, чтобы воспользоваться в стабильной сортировке подсчётом.
//   Но резуьтат сортировки подсчётом мы при этом процессе записываем
//   в старый;
//   и старые номера компонент по элементам, это наши цифры в сортироке
//   подсчётом, т.к. мы после сортировки должны получить новые номера
//   компонент по обоим парам, не только по первой, при этом мы
//   используем массив старых компонент, чтобы сравнивать.
// Мы не можем и проходится по старому, и писать туда новый порядок,
//   т.к. это перезатрёт позиции, в которые мы ещё не зашли.
// Если пишете какой-то алгоритм в первый раз, создавайте максимальное
//   количество массивов, для каждой величины по смыслу: новые величины
//   после итерации, старые до итерации и т.п. Потом в конце итерации
//   замените старые на новые.

// Сортировка по второй половине.
// Сортируем по второй половине, просто сдвинув
//   индексы: для каждой второй половины индекс
//   первой половины определяется однозначно, а
//   как отсортированы вторые половины знаем.
// Отсортированы суффиксы по первым 2^(k - 1) символам.
// Это вторые половины некоторых строк, т.к.
//   строки зациклены.
// Детально: просто возьмём любой суффикс, возьмём
//   вторую половину из первых 2^k символов. Это тоже
//   некоторый суффикс. И мы знаем порядок всех таких
//   суффиксов, если оставим их и отсортируем
//   (мультимножества строк совпадают).
// Переидем к первым половинам, вычтя половину длины,
//   получим упорядочивание строк длины 2^k по вторым
//   половинам. Т.е. мы знаем строку с минимальной
//   второй половиной, со второй по величине, если
//   просто произведем операции. Тогда просто к каждой
//   применим эту операцию и получим упорядочивание.
// TODO: найти это в оригинальной публикации, посмотреть, как там пишут, обсудить.

// Сортировка по первой половине.
// Сортируем по первой половине (по компоненте первого элемента пары) подсчётом.
// Сдвигов n, потому компонент эквивалентности нужно не более, чем n.
// Чтобы сортировать устойчиво по второй половине, нам нужно проходить
//   по элементам в перевернутом отсортированном порядке.
//   Нам нужен отсортрованный порядок, потому будем его хранить.
// TODO: потом вынести, чтобы постоянно память не выделять.
//   Это в шаги по оптимизации написать. Код оставить, просто
//   закомментировать. Указать наверху, что оптимизация №2, на первом
//   написании пропустить. А здесь указать, первое написание, понятное.
// Типичная сортировка подсчётом, правда алфавит -- компоненты
//   эквивалентности с прошлого шага.
